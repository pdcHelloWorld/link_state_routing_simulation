# link_state_routing_simulation
厂工计网课设之链路状态路由协议仿真系统

以下内容由Gemini 2.5 Pro生成，仅供参考
# 链路状态路由协议仿真系统

## 1. 项目简介

本项目是一个基于Python和PyQt5实现的链路状态路由协议仿真系统。它旨在通过可视化的方式，帮助用户理解链路状态路由协议（如OSPF）的核心工作原理，包括网络拓扑的构建、链路状态信息（LSA）的交换、使用Dijkstra算法计算最短路径以及动态维护路由表等过程。

该系统允许用户：
- 动态构建和修改网络拓扑结构。
- 设置节点间链路的代价。
- 模拟链路状态信息的泛洪过程。
- 查看每个路由器基于当前网络拓扑计算出的路由表。
- 观察网络拓扑变化（如链路代价改变、链路断开/新增）时，路由表如何动态更新。
- 保存和加载自定义的网络拓扑。

## 2. 系统要求

- Python 3.6 或更高版本
- PyQt5
- NetworkX
- Matplotlib
- NumPy

## 3. 安装指南

首先，请确保您的系统中已安装Python 3.6+。然后，通过pip安装所需的依赖库：

```bash
pip install PyQt5 networkx matplotlib numpy
```

## 4. 文件结构

```
link_state_routing_simulation/
├── main.py               # 主程序入口，负责启动应用
├── network.py            # 定义网络拓扑结构（节点、链路）及其管理功能
├── router.py             # 定义路由器对象的行为，包括LSA处理和路由表维护
├── link_state.py         # 实现链路状态协议的核心逻辑，如LSA的生成、泛洪和处理
├── dijkstra.py           # 实现Dijkstra最短路径算法
├── visualization_qt.py   # 实现基于PyQt5的图形用户界面和网络拓扑可视化
├── topology/             # 存放网络拓扑配置文件的目录
│   └── default.json      # 一个默认的网络拓扑示例
├── resources/            # (可选) 存放UI资源，如样式表、图标等
│   └── style.qss         # (可选) Qt样式表文件
└── README.md             # 本说明文档
```

## 5. 运行方法

进入项目根目录 `link_state_routing_simulation/`，然后执行以下命令启动仿真系统：

```bash
python main.py
```

## 6. 功能特性与使用说明

### 6.1 用户界面概览

系统主界面通常分为几个主要区域：
- **拓扑显示区**：位于界面中央或一侧，使用Matplotlib和NetworkX动态绘制当前的网络拓扑图，显示节点及其连接关系，并标注链路代价。
- **路由表显示区**：通常位于拓扑图的另一侧，允许用户选择一个网络节点，并查看该节点当前的路由表。路由表会显示目标节点、下一跳路由器以及到达目标节点的总代价。
- **控制面板/工具栏**：提供一系列按钮和输入控件，用于执行各种操作。

### 6.2 主要操作

1.  **构建/修改网络拓扑**：
    *   **添加节点**：通过界面按钮或菜单项，输入新节点的ID来创建节点。
    *   **添加链路**：选择两个已存在的节点，并指定它们之间链路的代价，创建一条双向链路。
    *   **修改链路代价**：选择一条已存在的链路，输入新的代价值以更新。
    *   **删除节点/链路**：选择要移除的节点或链路进行删除。

2.  **链路状态协议仿真**：
    *   **启动/停止协议**：有一个控制按钮用于启动或停止链路状态协议的仿真。
        *   启动后，各路由器节点会开始模拟交换链路状态信息（LSA），并基于收集到的信息计算和更新自己的路由表。
        *   拓扑图和路由表会动态反映协议运行状态。
    *   **动态更新**：当网络拓扑发生变化（如用户修改链路代价、添加/删除链路）且协议正在运行时，系统会自动触发LSA的更新和泛洪，各节点的路由表会随之重新计算和更新。

3.  **查看路由信息**：
    *   在路由表显示区，通过下拉列表或类似控件选择任意一个网络节点。
    *   系统会立即显示该选定节点的当前路由表。

4.  **拓扑管理**：
    *   **保存拓扑**：可以将当前的网络拓扑结构（包括节点、链路及其代价）保存到一个JSON文件中。
    *   **加载拓扑**：可以从之前保存的JSON文件中加载网络拓扑，方便重现特定的网络场景。系统启动时通常会加载一个默认的拓扑文件（如 `topology/default.json`）。

### 6.3 链路状态消息交换的体现

链路状态消息的交换是本系统的核心模拟内容之一，主要通过以下机制实现：
-   **LSA生成与泛洪**：当一个路由器的链路状态发生变化（如邻居链路代价改变、链路新增或断开），它会生成新的LSA，并通过其 `LinkStateProtocol` 模块将LSA发送给所有邻居。
-   **LSA接收与处理**：路由器接收到来自邻居的LSA后，会检查其序列号。如果是新的LSA，则更新本地的链路状态数据库，并将该LSA转发给除发送方以外的其他所有邻居（泛洪）。
-   **周期性更新**：部分实现可能包含周期性的LSA发送，以确保链路状态数据库的同步。
-   **路由计算触发**：每当链路状态数据库更新后，路由器会重新运行Dijkstra算法，根据最新的全局拓扑信息计算最短路径，并更新其路由表。

用户可以通过观察路由表在拓扑变化后的动态调整，间接了解链路状态消息交换和路由重新计算的过程。

## 7. 注意事项

-   本系统主要用于完成课设目的，可能未完全实现实际链路状态协议（如OSPF）的所有复杂特性（如区域划分、认证、多种LSA类型等）。
-   可视化效果和性能可能受网络规模影响。对于非常大的网络，绘图和计算可能会有延迟。

希望本仿真系统能帮助您更好地理解链路状态路由协议！
